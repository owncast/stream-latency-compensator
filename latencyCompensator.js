/*
The Owncast Latency Compensator.

It will try to slowly adjust the playback rate to enable the player to get
further into the future, with the goal of being as close to the live edge as
possible, without causing any buffering events.

How does latency occur?
Two pieces are at play. The first being the server. The larger each segment is
that is being generated by Owncast, the larger gap you are going to be from
live when you begin playback.

Second is your media player.
The player tries to play every segment as it comes in.
However, your computer is not always 100% in playing things in real time, and
there are natural stutters in playback. So if one frame is delayed in playback
you may not see it visually, but now you're one frame behind. Eventually this
can compound and you can be many seconds behind.

How to help with this? The Owncast Latency Compensator will:
  - Determine the start (max) and end (min) latency values.
  - Keep an eye on download speed and stop compensating if it drops too low.
  - Limit the playback speedup rate so it doesn't sound weird by jumping speeds.
  - Force a large jump to into the future once compensation begins.
  - Dynamically calculate the speedup rate based on network speed.
  - Pause the compensation if buffering events occur.
  - Completely give up on all compensation if too many buffering events occur.
*/

const REBUFFER_EVENT_LIMIT = 4; // Reduced from 4 - Max number of buffering events before we stop compensating for latency.
const MIN_BUFFER_DURATION = 200; // Reduced from 200 - Min duration a buffer event must last to be counted.
const MAX_SPEEDUP_RATE = 1.08; // The max playback rate when compensating for latency.
const MAX_SPEEDUP_RAMP = 0.005; // The max amount we will increase the playback rate at once.
const TIMEOUT_DURATION = 30 * 1000; // Increased from 30s - The amount of time we stop handling latency after certain events.
const CHECK_TIMER_INTERVAL = 3 * 1000; // Increased from 1s - How often we check if we should be compensating for latency.
const SPEED_ADJUSTMENT_INTERVAL = 1 * 1000; // New - How often to make micro speed adjustments
const BUFFERING_AMNESTY_DURATION = 4 * 1000 * 60; // Increased from 3min - How often until a buffering event expires.
const REQUIRED_BANDWIDTH_RATIO = 2.0; // Increased from 1.5 - The player:bitrate ratio required to enable compensating for latency.
const HIGHEST_LATENCY_SEGMENT_LENGTH_MULTIPLIER = 2.2; // Increased from 2.2 - Segment length * this value is when we start compensating.
const LOWEST_LATENCY_SEGMENT_LENGTH_MULTIPLIER = 1.7; // Increased from 1.8 - Segment length * this value is when we stop compensating.
const MIN_LATENCY = 4 * 1000; // Increased from 4s - The absolute lowest we'll continue compensation to be running at.
const MAX_LATENCY = 15 * 1000; // Increased from 15s - The absolute highest we'll allow a target latency to be before we start compensating.
const MAX_JUMP_LATENCY = 5 * 1000; // Increased from 5s - How much behind the max latency we need to be behind before we allow a jump.
const MAX_JUMP_FREQUENCY = 20 * 1000; // Increased from 20s - How often we'll allow a time jump.
const MAX_ACTIONABLE_LATENCY = 90 * 1000; // Increased from 80s - If latency is seen to be greater than this then something is wrong.
const STARTUP_WAIT_TIME = 20 * 1000; // Increased from 10s - The amount of time after we start up that we'll allow monitoring to occur.
const MIN_BUFFER_HEALTH = 5; // New - Minimum seconds of healthy buffer before taking action
const CONSECUTIVE_STABLE_CHECKS = 3; // New - How many stable checks before allowing speed changes

class LatencyCompensator {
  constructor(player) {
    this.player = player;
    this.playing = false;
    this.enabled = false;
    this.running = false;
    this.inTimeout = false;
    this.jumpingToLiveIgnoreBuffer = false;
    this.timeoutTimer = 0;
    this.timeoutEndingAt = 0;
    this.checkTimer = 0;
    this.bufferingCounter = 0;
    this.bufferingTimer = 0;
    this.playbackRate = 1.0;
    this.targetPlaybackRate = 1.0;
    this.lastJumpOccurred = null;
    this.startupTime = new Date();
    this.clockSkewMs = 0;
    this.currentLatency = null;
    this.speedAdjustmentTimer = 0; // New - timer for smooth speed changes
    this.consecutiveStableChecks = 0; // New - track stability
    this.bandwidthHistory = []; // New - track bandwidth over time
    this.playableBufferHistory = []; // New - track buffer health
    this.lastSpeedChange = new Date(); // New - prevent too frequent changes

    // Keep track of all the latencies we encountered buffering events
    // in order to determine a new minimum latency.
    this.bufferedAtLatency = [];

    this.player.on("playing", this.handlePlaying.bind(this));
    this.player.on("pause", this.handlePause.bind(this));
    this.player.on("error", this.handleError.bind(this));
    this.player.on("waiting", this.handleBuffering.bind(this));
    this.player.on("stalled", this.handleBuffering.bind(this));
    this.player.on("ended", this.handleEnded.bind(this));
    this.player.on("canplaythrough", this.handlePlaying.bind(this));
    this.player.on("canplay", this.handlePlaying.bind(this));

    this.onStats = null;

    this.check = this.check.bind(this);
    this.start = this.start.bind(this);
    this.enable = this.enable.bind(this);
    this.countBufferingEvent = this.countBufferingEvent.bind(this);
    this.smoothSpeedAdjustment = this.smoothSpeedAdjustment.bind(this); // New
  }

  // To keep our client clock in sync with the server clock to determine
  // accurate latency the clock skew should be set here to be used in
  // the calculation. Otherwise if somebody's client clock is significantly
  // off it will have a very incorrect latency determination and make bad
  // decisions.
  setClockSkew(skewMs) {
    this.clockSkewMs = skewMs;
  }

  // New method - smooth speed adjustment for imperceptible changes
  smoothSpeedAdjustment() {
    if (!this.running || !this.enabled || this.inTimeout) {
      console.log("Skipping speed adjustment - not running or in timeout");
      this.setPlaybackRate(1.0);
      this.reportStats(0, 0);
      return;
    }

    const currentRate = this.playbackRate;
    const targetRate = this.targetPlaybackRate;

    // If we're close enough to target, set it exactly
    if (Math.abs(currentRate - targetRate) < MAX_SPEEDUP_RAMP) {
      this.setPlaybackRate(targetRate);
      if (targetRate === 1.0) {
        clearInterval(this.speedAdjustmentTimer);
        this.speedAdjustmentTimer = 0;
      }
      return;
    }

    // Make micro adjustment toward target
    let newRate;
    if (currentRate < targetRate) {
      newRate = Math.min(currentRate + MAX_SPEEDUP_RAMP, targetRate);
    } else {
      newRate = Math.max(currentRate - MAX_SPEEDUP_RAMP, targetRate);
    }

    console.log("Adjusting playback rate from", currentRate, "to", targetRate);
    this.setPlaybackRate(newRate);
  }

  // New method - get conservative bandwidth estimate
  getAverageBandwidth() {
    if (this.bandwidthHistory.length < 5) {
      return null;
    }
    // Use 30th percentile for conservative estimate
    const sorted = [...this.bandwidthHistory].sort((a, b) => a - b);
    const index = Math.floor(sorted.length * 0.3);
    return sorted[index];
  }

  // New method - get average playable buffer
  getAveragePlayableBuffer() {
    if (this.playableBufferHistory.length === 0) {
      return 0;
    }
    return (
      this.playableBufferHistory.reduce((a, b) => a + b, 0) /
      this.playableBufferHistory.length
    );
  }

  // New method - check if buffer is healthy and stable
  isBufferHealthy(playableBufferSeconds) {
    // Track buffer history
    this.playableBufferHistory.push(playableBufferSeconds);
    if (this.playableBufferHistory.length > 10) {
      this.playableBufferHistory.shift();
    }

    // Need minimum buffer
    if (playableBufferSeconds < MIN_BUFFER_HEALTH) {
      return false;
    }

    // Check if buffer is stable or growing
    if (this.playableBufferHistory.length >= 3) {
      const recent = this.playableBufferHistory.slice(-3);
      const trend = recent[2] - recent[0];
      if (trend < -2) {
        // Buffer is shrinking rapidly
        return false;
      }
    }

    return true;
  }

  // This is run on a timer to check if we should be compensating for latency.
  check() {
    // We have an arbitrary delay at startup to allow the player to run
    // normally and hopefully get a bit of a buffer of segments before we
    // start messing with it.
    if (new Date().getTime() - this.startupTime.getTime() < STARTUP_WAIT_TIME) {
      return;
    }

    // If we're paused then do nothing.
    if (this.player.paused()) {
      this.consecutiveStableChecks = 0;
      return;
    }

    if (this.player.seeking()) {
      this.consecutiveStableChecks = 0;
      return;
    }

    if (this.inTimeout) {
      return;
    }

    if (!this.enabled) {
      return;
    }

    const tech = this.player.tech({ IWillNotUseThisInPlugins: true });

    // We need access to the internal tech of VHS to move forward.
    // If running under an Apple browser that uses CoreMedia (Safari)
    // we do not have access to this as the tech is internal to the OS.
    if (!tech || !tech.vhs) {
      return;
    }

    // Network state 2 means we're actively using the network.
    // We only want to attempt latency compensation if we're continuing to
    // download new segments.
    const networkState = this.player.networkState();
    if (networkState !== 2) {
      this.consecutiveStableChecks = 0;
      return;
    }

    // Determine how much of the current playlist's bandwidth requirements
    // we're utilizing. If it's too high then we can't afford to push
    // further into the future because we're downloading too slowly.
    const currentPlaylist = tech.vhs.playlists.media();
    const currentPlaylistBandwidth = currentPlaylist.attributes.BANDWIDTH;
    const playerBandwidth = tech.vhs.systemBandwidth;
    const bandwidthRatio = playerBandwidth / currentPlaylistBandwidth;

    // Track bandwidth history
    if (playerBandwidth > 0 && bandwidthRatio > 0) {
      this.bandwidthHistory.push(bandwidthRatio);
      if (this.bandwidthHistory.length > 10) {
        this.bandwidthHistory.shift();
      }
    }

    try {
      const segment = getCurrentlyPlayingSegment(tech);
      if (!segment) {
        return;
      }

      // Get current playable buffer
      const playableBufferSeconds =
        this.player.buffered().end(0) - this.player.currentTime();

      // Check buffer health
      if (!this.isBufferHealthy(playableBufferSeconds)) {
        this.consecutiveStableChecks = 0;
        if (this.running) {
          this.stop();
          this.timeout();
        }
        return;
      }

      // Use average bandwidth for more stable decisions
      const avgBandwidthRatio = this.getAverageBandwidth() || bandwidthRatio;

      // If we're running low on playable video, then stop the compensator
      // temporarily to allow the player to catch up.
      if (playableBufferSeconds < 2) {
        this.timeout();
        return;
      }

      // Track stability
      this.consecutiveStableChecks++;

      // How far away from live edge do we stop the compensator.
      const computedMinLatencyThreshold = Math.max(
        MIN_LATENCY,
        segment.duration * 1000 * LOWEST_LATENCY_SEGMENT_LENGTH_MULTIPLIER
      );

      // Create an array of all the buffering events in the past along with
      // the computed min latency above.
      const targetLatencies = this.bufferedAtLatency.concat([
        computedMinLatencyThreshold,
      ]);

      // Determine if we need to reduce the minimum latency we computed
      // above based on buffering events that have taken place in the past by
      // creating an array of all the buffering events and the above computed
      // minimum latency target and averaging all those values.
      const minLatencyThreshold =
        targetLatencies.reduce((sum, current) => sum + current, 0) /
        targetLatencies.length;

      // How far away from live edge do we start the compensator.
      let maxLatencyThreshold = Math.max(
        minLatencyThreshold * 1.4,
        Math.min(
          segment.duration * 1000 * HIGHEST_LATENCY_SEGMENT_LENGTH_MULTIPLIER,
          MAX_LATENCY
        )
      );

      // If this newly adjusted minimum latency ends up being greater than
      // the previously computed maximum latency then reset the maximum
      // value using the minimum + an offset.
      if (minLatencyThreshold >= maxLatencyThreshold) {
        maxLatencyThreshold = minLatencyThreshold + 3000;
      }

      const segmentTime = segment.dateTimeObject.getTime();
      const now = new Date().getTime() + this.clockSkewMs;
      const latency = now - segmentTime;
      this.currentLatency = latency;

      this.reportStats(minLatencyThreshold, maxLatencyThreshold);

      // Since the calculation of latency is based on clock times, it's possible
      // things can be reported incorrectly. So we use a sanity check here to
      // simply bail if the latency is reported to so high we think the whole
      // thing is wrong. We can't make decisions based on bad data, so give up.
      // This can also occur if somebody pauses for a long time and hits play
      // again but it's not really possible to know the difference between
      // the two scenarios.
      if (Math.abs(latency) > MAX_ACTIONABLE_LATENCY) {
        this.timeout();
        return;
      }

      if (latency > maxLatencyThreshold) {
        // Only jump if we have excellent conditions
        if (
          latency > maxLatencyThreshold + MAX_JUMP_LATENCY &&
          this.shouldJumpToLive() &&
          playableBufferSeconds > 10 &&
          avgBandwidthRatio > REQUIRED_BANDWIDTH_RATIO &&
          this.consecutiveStableChecks >= CONSECUTIVE_STABLE_CHECKS
        ) {
          // More conservative jump amount
          const jumpAmount = Math.min(
            playableBufferSeconds * 0.5,
            latency / 1000 - segment.duration * 5
          );
          const seekPosition = this.player.currentTime() + jumpAmount;
          console.info(
            "latency",
            latency / 1000,
            "jumping",
            jumpAmount,
            "to live from ",
            this.player.currentTime(),
            " to ",
            seekPosition
          );

          this.jump(seekPosition);
          return;
        }

        // We must have at least one segment's worth of buffer available.
        if (
          playableBufferSeconds < segment.duration * 2 ||
          avgBandwidthRatio < REQUIRED_BANDWIDTH_RATIO
        ) {
          this.timeout();
          return;
        }

        // Only adjust speed if we're stable and have been for a while
        if (
          this.consecutiveStableChecks >= CONSECUTIVE_STABLE_CHECKS &&
          this.bufferingCounter === 0 &&
          new Date() - this.lastSpeedChange > 10000 // 10 seconds between changes
        ) {
          // More conservative speed calculation
          const avgPlayableBuffer = this.getAveragePlayableBuffer();
          const proposedPlaybackRateFromPlayableBuffer =
            1.0 + avgPlayableBuffer * 0.004; // Reduced from 0.008
          const proposedPlaybackRateFromTransferSpeed = avgBandwidthRatio * 0.2; // Reduced from 0.33

          var proposedPlaybackRate = Math.min(
            proposedPlaybackRateFromPlayableBuffer,
            proposedPlaybackRateFromTransferSpeed
          );

          // But limit the playback rate to a max value.
          proposedPlaybackRate = Math.max(
            Math.min(proposedPlaybackRate, MAX_SPEEDUP_RATE),
            1.0
          );

          // Limit to 4 decimal places of precision.
          proposedPlaybackRate =
            Math.round(proposedPlaybackRate * Math.pow(10, 4)) /
            Math.pow(10, 4);

          // Set target and let smooth ramping handle it
          this.start(proposedPlaybackRate);
          this.lastSpeedChange = new Date();
        }
      } else if (latency <= minLatencyThreshold) {
        this.stop();
      }

      console.info(
        "latency",
        latency / 1000,
        "min",
        minLatencyThreshold / 1000,
        "max",
        maxLatencyThreshold / 1000,
        "playable",
        playableBufferSeconds,
        "playback rate",
        this.playbackRate,
        "target rate",
        this.targetPlaybackRate,
        "enabled:",
        this.enabled,
        "running: ",
        this.running,
        "skew: ",
        this.clockSkewMs,
        "rebuffer events: ",
        this.bufferingCounter,
        "stable checks:",
        this.consecutiveStableChecks
      );
    } catch (err) {
      console.trace(err);
    }
  }

  shouldJumpToLive() {
    // If we've been rebuffering some recently then don't make it worse by
    // jumping more into the future.
    if (this.bufferingCounter > 0) {
      // Reduced from 1
      return false;
    }

    const now = new Date().getTime();
    const delta = now - this.lastJumpOccurred;
    return delta > MAX_JUMP_FREQUENCY;
  }

  jump(seekPosition) {
    this.jumpingToLiveIgnoreBuffer = true;
    this.performedInitialLiveJump = true;

    this.lastJumpOccurred = new Date();
    this.consecutiveStableChecks = 0;

    // Reset to normal speed when jumping
    this.targetPlaybackRate = 1.0;
    this.setPlaybackRate(1.0);

    console.info(
      "current time",
      this.player.currentTime(),
      "seeking to",
      seekPosition
    );
    this.player.currentTime(seekPosition);

    setTimeout(() => {
      this.jumpingToLiveIgnoreBuffer = false;
    }, 10000); // Increased from 5000
  }

  setPlaybackRate(rate) {
    this.playbackRate = rate;
    this.player.playbackRate(rate);
    this.targetPlaybackRate = rate;
  }

  start(rate = 1.0) {
    if (this.inTimeout || !this.enabled || rate === this.targetPlaybackRate) {
      return;
    }

    this.running = true;
    this.targetPlaybackRate = rate;
    this.enableOnlyLowQualityPlayback();

    // Start smooth adjustment timer if not running
    if (!this.speedAdjustmentTimer) {
      this.speedAdjustmentTimer = setInterval(
        this.smoothSpeedAdjustment,
        SPEED_ADJUSTMENT_INTERVAL
      );
    }
  }

  stop() {
    if (this.running) {
      console.log("stopping latency compensator...");
    }
    this.running = false;
    this.targetPlaybackRate = 1.0;
    this.enableAllQualityPlayback();
    // Let smooth ramping bring us back to 1.0
  }

  enable() {
    this.enabled = true;
    clearInterval(this.checkTimer);
    clearTimeout(this.bufferingTimer);

    this.checkTimer = setInterval(() => {
      this.check();
    }, CHECK_TIMER_INTERVAL);
  }

  // Disable means we're done for good and should no longer compensate for latency.
  disable() {
    clearInterval(this.checkTimer);
    clearInterval(this.speedAdjustmentTimer);
    clearTimeout(this.timeoutTimer);
    this.stop();
    this.setPlaybackRate(1.0);
    this.enabled = false;
  }

  timeout() {
    if (this.jumpingToLiveIgnoreBuffer) {
      return;
    }

    this.inTimeout = true;
    this.stop();
    this.consecutiveStableChecks = 0;

    clearTimeout(this.timeoutTimer);
    this.timeoutTimer = setTimeout(() => {
      this.endTimeout();
    }, TIMEOUT_DURATION);
    if (this.timeoutEndingAt === 0) {
      this.timeoutEndingAt = new Date().getTime() + TIMEOUT_DURATION;
    }
    this.reportStats(0, 0);
  }

  endTimeout() {
    clearTimeout(this.timeoutTimer);
    this.inTimeout = false;
    this.timeoutEndingAt = 0;
  }

  handlePlaying() {
    const wasPreviouslyPlaying = this.playing;
    this.playing = true;

    clearTimeout(this.bufferingTimer);
    if (!this.enabled) {
      return;
    }

    if (!this.shouldJumpToLive()) {
      return;
    }

    // If we were not previously playing (was paused, or this is a cold start)
    // seek to live immediately on starting playback to handle any long-pause
    // scenarios or somebody starting far back from the live edge.
    // If we were playing previously then that means we're probably coming back
    // from a rebuffering event, meaning we should not be adding more seeking
    // to the mix, just let it play.
    if (!wasPreviouslyPlaying && this.performedInitialLiveJump) {
      this.jumpingToLiveIgnoreBuffer = true;
      this.player.liveTracker.seekToLiveEdge();
      this.lastJumpOccurred = new Date();
    }
  }

  handlePause() {
    this.playing = false;
    this.consecutiveStableChecks = 0;
  }

  handleEnded() {
    if (!this.enabled) {
      return;
    }

    this.disable();
  }

  handleError(e) {
    if (!this.enabled) {
      return;
    }

    this.timeout();
  }

  countBufferingEvent() {
    this.bufferingCounter++;
    this.consecutiveStableChecks = 0;

    if (this.bufferingCounter > REBUFFER_EVENT_LIMIT) {
      this.disable();
      return;
    }

    this.bufferedAtLatency.push(this.currentLatency);

    console.log(
      "latency compensation timeout due to buffering:",
      this.bufferingCounter,
      "buffering events of",
      REBUFFER_EVENT_LIMIT
    );

    // Allow us to forget about old buffering events if enough time goes by.
    setTimeout(() => {
      if (this.bufferingCounter > 0) {
        this.bufferingCounter--;
        this.bufferedAtLatency.shift();
      }
    }, BUFFERING_AMNESTY_DURATION);
  }

  handleBuffering() {
    console.log("handleBuffering...");
    if (new Date().getTime() - this.startupTime.getTime() < STARTUP_WAIT_TIME) {
      return;
    }

    if (this.jumpingToLiveIgnoreBuffer) {
      return;
    }

    // Stop any speed adjustments immediately
    if (this.running) {
      this.targetPlaybackRate = 1.0;
      this.setPlaybackRate(1.0);
    }

    this.timeout();

    clearTimeout(this.bufferingTimer);
    this.bufferingTimer = setTimeout(() => {
      this.countBufferingEvent();
    }, MIN_BUFFER_DURATION);
  }

  enableOnlyLowQualityPlayback() {}

  enableAllQualityPlayback() {}

  reportStats(minEndingLatency, maxStartingLatency) {
    if (!this.onStats) {
      return;
    }

    const stats = {
      latency: this.currentLatency,
      playbackRate: this.playbackRate,
      targetPlaybackRate: this.player.playbackRate(),
      enabled: this.enabled,
      running: this.running,
      bufferingEvents: this.bufferingCounter,
      inTimeout: this.inTimeout,
      timeoutRemaining: this.inTimeout
        ? this.timeoutEndingAt - new Date().getTime()
        : 0,
      minEndingLatency: minEndingLatency,
      maxStartingLatency: maxStartingLatency,
      averageBufferSeconds: this.getAveragePlayableBuffer(), // Added
      averageBandwidthRatio: this.getAverageBandwidth(), // Added
      consecutiveStableChecks: this.consecutiveStableChecks, // Added
    };

    this.onStats(stats);
  }
}

function getCurrentlyPlayingSegment(tech) {
  var target_media = tech.vhs.playlists.media();
  var snapshot_time = tech.currentTime();

  var segment;

  // Iterate trough available segments and get first within which snapshot_time is
  for (var i = 0, l = target_media.segments.length; i < l; i++) {
    // Note: segment.end may be undefined or is not properly set
    if (snapshot_time < target_media.segments[i].end) {
      segment = target_media.segments[i];
      break;
    }
  }

  if (!segment) {
    segment = target_media.segments[0];
  }

  return segment;
}

export default LatencyCompensator;
